/* Copyright 2025 Chen Xingqiang (YiRage Project)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * This file is part of YiRage (Yi Revolutionary AGile Engine)
 * 
 * Ascend RMS Norm Kernel
 * 
 * RMS normalization for Huawei Ascend NPU backend.
 */

#include "yirage/kernel/device_memory_manager.h"
#include "yirage/kernel/graph.h"
#include "yirage/kernel/operator.h"
#include "yirage/utils/ascend_helper.h"
#include "yirage/utils/fingerprint_functions.h"
#include <cassert>

#ifdef __ASCEND__
#include "acl/acl.h"
#endif

namespace yirage {
namespace kernel {

using namespace yirage::type;
using namespace yirage::config;
using namespace yirage::utils;

#ifdef YIRAGE_FINGERPRINT_USE_ASCEND

/**
 * @brief Compute RMS normalization fingerprint on Ascend
 */
#ifdef __ASCEND__
__global__
#endif
void compute_rms_norm_fingerprint_ascend(
    yirage::type::FPType *input_ptr,
    yirage::type::FPType *output_ptr,
    int num_samples,
    int norm_size,
    yirage::type::FPType *div_p_table,
    yirage::type::FPType *div_q_table,
    yirage::type::FPType *sqrt_p_table,
    yirage::type::FPType *sqrt_q_table) {
  
#ifdef __ASCEND__
  int sample_idx = threadIdx.x + blockIdx.x * blockDim.x;
#else
  int sample_idx = 0;
#endif
  
  if (sample_idx < num_samples) {
    // Compute sum of squares
    yirage::type::FPType square_sum = 0;
    for (int i = 0; i < norm_size; i++) {
      yirage::type::FPType x = input_ptr[sample_idx * norm_size + i];
      yirage::type::FPType x_sq = compute_mul_fingerprint(x, x);
      square_sum = compute_add_fingerprint(square_sum, x_sq);
    }
    
    // Compute mean
    yirage::type::FPType n = norm_size % FP_PQ;
    yirage::type::FPType mean = compute_div_fingerprint(
        square_sum, n, div_p_table, div_q_table);
    
    // Compute RMS (sqrt of mean)
    yirage::type::FPType rms = compute_sqrt_fingerprint(
        mean, sqrt_p_table, sqrt_q_table);
    
    // Normalize
    for (int i = 0; i < norm_size; i++) {
      yirage::type::FPType x = input_ptr[sample_idx * norm_size + i];
      output_ptr[sample_idx * norm_size + i] = compute_div_fingerprint(
          x, rms, div_p_table, div_q_table);
    }
  }
}

bool KNRMSNormOp::fingerprint(void) {
  assert(kgraph->gpu_dim.y == 1);
  assert(kgraph->gpu_dim.z == 1);
  
  yirage::kernel::DeviceMemoryManager *dmm =
      yirage::kernel::DeviceMemoryManager::get_instance();
  
#ifdef __ASCEND__
  checkACL(aclrtSetDevice(dmm->gpu_id));
#endif

  DTensor const &input_tensor = input_tensors[0];
  DTensor const &output_tensor = output_tensors[0];
  
  // Calculate dimensions
  int norm_size = 1;
  for (int i = 0; i < normalized_size; i++) {
    norm_size *= input_tensor.dim[input_tensor.num_dims - 1 - i];
  }
  
  int num_samples = input_tensor.num_elements() / norm_size;
  
  int const num_threads_per_blk = 256;
  int num_blocks =
      (num_samples + num_threads_per_blk - 1) / num_threads_per_blk;
  
  for (int gpu_id = 0; gpu_id < kgraph->gpu_dim.x; gpu_id++) {
    yirage::type::FPType *input_fp_ptr =
        reinterpret_cast<yirage::type::FPType *>(
            dmm->fp_base_ptr[gpu_id] + input_tensor.fp_offset);
    yirage::type::FPType *output_fp_ptr =
        reinterpret_cast<yirage::type::FPType *>(
            dmm->fp_base_ptr[gpu_id] + output_tensor.fp_offset);
    
#ifdef __ASCEND__
    compute_rms_norm_fingerprint_ascend<<<num_blocks, num_threads_per_blk>>>(
        input_fp_ptr, output_fp_ptr, num_samples, norm_size,
        dmm->div_p_lookup_table, dmm->div_q_lookup_table,
        dmm->sqrt_p_lookup_table, dmm->sqrt_q_lookup_table);
    checkACL(aclrtSynchronizeDevice());
#else
    // CPU fallback
    for (int s = 0; s < num_samples; s++) {
      FPType square_sum = 0;
      for (int i = 0; i < norm_size; i++) {
        FPType x = input_fp_ptr[s * norm_size + i];
        square_sum = compute_add_fingerprint(square_sum, 
                                             compute_mul_fingerprint(x, x));
      }
      FPType mean = compute_div_fingerprint(square_sum, norm_size % FP_PQ,
                                            dmm->div_p_lookup_table, 
                                            dmm->div_q_lookup_table);
      FPType rms = compute_sqrt_fingerprint(mean, dmm->sqrt_p_lookup_table,
                                            dmm->sqrt_q_lookup_table);
      for (int i = 0; i < norm_size; i++) {
        FPType x = input_fp_ptr[s * norm_size + i];
        output_fp_ptr[s * norm_size + i] = compute_div_fingerprint(
            x, rms, dmm->div_p_lookup_table, dmm->div_q_lookup_table);
      }
    }
#endif
  }
  return true;
}

#endif // YIRAGE_FINGERPRINT_USE_ASCEND

} // namespace kernel
} // namespace yirage

