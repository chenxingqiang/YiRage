/* Copyright 2025 Chen Xingqiang (YiRage Project)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * This file is part of YiRage (Yi Revolutionary AGile Engine)
 * 
 * Ascend Reduction Kernel
 * 
 * Reduction operations for Huawei Ascend NPU backend.
 */

#include "yirage/kernel/device_memory_manager.h"
#include "yirage/kernel/graph.h"
#include "yirage/kernel/operator.h"
#include "yirage/utils/ascend_helper.h"
#include "yirage/utils/fingerprint_functions.h"
#include <cassert>

#ifdef __ASCEND__
#include "acl/acl.h"
#endif

namespace yirage {
namespace kernel {

using namespace yirage::type;
using namespace yirage::config;
using namespace yirage::utils;

#ifdef YIRAGE_FINGERPRINT_USE_ASCEND

/**
 * @brief Compute reduction fingerprint on Ascend
 */
#ifdef __ASCEND__
__global__
#endif
void compute_reduction_fingerprint_ascend(yirage::type::FPType *input_ptr,
                                          yirage::type::FPType *output_ptr,
                                          int output_num_elements,
                                          int reduction_degree,
                                          int inner_range) {
#ifdef __ASCEND__
  int tid = threadIdx.x + blockIdx.x * blockDim.x;
#else
  int tid = 0;
#endif
  
  int total_threads = output_num_elements;
  
  for (int i = tid; i < output_num_elements; i += total_threads) {
    int pos = (i / inner_range) * (inner_range * reduction_degree) +
              i % inner_range;
    yirage::type::FPType result = 0;
    for (int k = 0; k < reduction_degree; k++) {
      result = compute_add_fingerprint(result, input_ptr[pos]);
      pos += inner_range;
    }
    output_ptr[i] = result;
  }
}

bool KNReductionOp::fingerprint(void) {
  assert(kgraph->gpu_dim.y == 1);
  assert(kgraph->gpu_dim.z == 1);
  
  yirage::kernel::DeviceMemoryManager *dmm =
      yirage::kernel::DeviceMemoryManager::get_instance();
  
#ifdef __ASCEND__
  checkACL(aclrtSetDevice(dmm->gpu_id));
#endif

  DTensor const &input_tensor = input_tensors[0];
  DTensor const &output_tensor = output_tensors[0];
  
  int output_num_elements = output_tensor.num_elements();
  int reduction_dim = this->reduction_dim;
  int reduction_degree = input_tensor.dim[reduction_dim];
  
  int inner_range = 1;
  for (int i = reduction_dim; i < input_tensor.num_dims; i++) {
    inner_range *= output_tensor.dim[i];
  }
  
  int const num_threads_per_blk = 256;
  int num_blocks =
      (output_num_elements + num_threads_per_blk - 1) / num_threads_per_blk;
  
  for (int gpu_id = 0; gpu_id < kgraph->gpu_dim.x; gpu_id++) {
    yirage::type::FPType *input_fp_ptr =
        reinterpret_cast<yirage::type::FPType *>(
            dmm->fp_base_ptr[gpu_id] + input_tensor.fp_offset);
    yirage::type::FPType *output_fp_ptr =
        reinterpret_cast<yirage::type::FPType *>(
            dmm->fp_base_ptr[gpu_id] + output_tensor.fp_offset);
    
#ifdef __ASCEND__
    compute_reduction_fingerprint_ascend<<<num_blocks, num_threads_per_blk>>>(
        input_fp_ptr, output_fp_ptr, output_num_elements, 
        reduction_degree, inner_range);
    checkACL(aclrtSynchronizeDevice());
#else
    // CPU fallback
    for (int i = 0; i < output_num_elements; i++) {
      int pos = (i / inner_range) * (inner_range * reduction_degree) +
                i % inner_range;
      FPType result = 0;
      for (int k = 0; k < reduction_degree; k++) {
        result = compute_add_fingerprint(result, input_fp_ptr[pos]);
        pos += inner_range;
      }
      output_fp_ptr[i] = result;
    }
#endif
  }
  return true;
}

#endif // YIRAGE_FINGERPRINT_USE_ASCEND

} // namespace kernel
} // namespace yirage

